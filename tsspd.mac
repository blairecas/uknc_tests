;===================================================================================
;
;		     Тест скорости выполнения команд ПП, ЦП, а
;		  так же скорости памяти и остального железа УКНЦ
;
;				  Версия 0.1c
;
;			      (c) dr.Titus 2012
;
;===================================================================================

		.MCall	.TTYIN, .TTYOUT, .Print, .Exit
	
		.RADIX	10
	
		.CSect

CSR2STATE	=	^O176674
CSR2DATA	=	^O176676

PPLADR		=	^O177010
PPL12DATA	=	^O177014

TMRSTATE	=	^O177710

$JSW    	=       ^O44
TTSPC$  	=       ^O10000

TPLCPU		=	60			;Тактов на дополнительные команды в каждом цикле
TPSCPU		=	100			;Такты на вход и выход из цикла замера

TPLPPU		=	84			;Тактов на дополнительные команды в каждом цикле
TPSPPU		=	220			;Такты на вход и выход из цикла замера


;===============================================
Start:


;----------------------------------------------- Копировать код в память PPU

		MOV	#<PPUTEnd-PPUTBeg>,MPA2	;Аргумент 2 - длина программы в PPU
		MOVB	#1,MPType		;Комана запроса памяти PPU
		CALL	PPUOut			;=> Передача параметров
		BNE	PPUErr			;Если ошибка, то --> PPUErr
		
		MOV	MPA1,R0			;PPUDisp = PPUMBeg - PPUTBeg
		SUB	#PPUTBeg,R0		;(смещение между программой в CPU и ее копией в PPU)
		MOV	R0,PPUDisp		;
		
		MOV	MPA1,PPUMBeg		;Сохранить адрес начала выделенной памяти в PPUMBeg
						;Аргумент 1 - адрес начала программы в PPU
		MOV	#PPUTBeg,MPA2		;Аргумент 2 - адрес начала программы в CPU
		MOV	#<PPUTEnd-PPUTBeg>,MPA3	;Аргумент 3 - длина программы
		MOVB	#16,MPType		;Комана копирования из памяти CPU в память PPU
		CALL	PPUOut			;=> Передача параметров
		BNE	PPUErr			;Если ошибка, то --> PPUErr
		
		CLR	PPUFlg			;Сбросить флаг того, что код находится в памяти PPU
		
;-----------------------------------------------

	
		.Print	#KeyOFF			;Отключить клавиатуру
	
		MOV	#Text0,R1		;Информация о тесте
		CALL	PrnStr			;Печатать название теста
				
;----------------------------------------------- Тестирование быстродействия команд PPU
PPUSpeedTest:

		MOV	#Text3,R1		;
		CALL	PrnStr			;Печатать название теста
		

;		MOV	SP,SP			;[T] Точка останова для отладчика

		MOV	#CPUTTAB,R1		;R1 - Таблица для тестирования быстродействия CPU
1$:		
		CALL	PPUTCom			;Тестирование одной команды (группы команд) PPU
		
		TST	(R1)			;Если еще не конец таблицы,
		BNE	1$			;то цикл --> 1$


;----------------------------------------------- Тестирование быстродействия команд CPU
CPUSpeedTest:

		MOV	#Text1,R1		;
		CALL	PrnStr			;Печатать название теста
		
		MOV	#CPUTTAB,R1		;R1 - Таблица для тестирования быстродействия CPU
1$:		
		CALL	CPUTCom			;Тестирование одной команды (группы команд) CPU
		
		TST	(R1)			;Если еще не конец таблицы,
		BNE	1$			;то цикл --> 1$
		

;-----------------------------------------------
ExitTest:
			
						;Освободить память PPU
		MOV	PPUMBeg,MPA1		;Аргумент 1 - адрес начала выделенной памяти
		MOV	#<PPUTEnd-PPUTBeg>,MPA2	;Аргумент 2 - длина выделенной памяти
		MOVB	#2,MPType		;Комана освобождения памяти PPU
		CALL	PPUOut			;=> Передача параметров
		BNE	PPUErr			;Если ошибка, то --> PPUErr

		.Print	#KeyON			;Включить клавиатуру
	
		.Exit
		
		
		
		
		
		
		
		
;===================================================================================
;
;		Функция копирования и запуска программы пользователя в PPU
;
;	Входные данные:  R3 - адрес программы
;			 R4 - длина программы в словах
;			 R5 - длина буфера для программы в словах
;
;===================================================================================
PPURun:
		MOV	R5,R2			;
		ADD	R4,R2			;R2 = R5 + R4 (сумма длины буфера и программы)	
		MOV	R2,MPA2			;Записать длину в аргумент 2
		MOVB	#1,MPType		;Комана запроса памяти PPU
		CALL	PPUOut			;=> Передача параметров
		BNE	PPUErr			;Если ошибка, то --> PPUErr

		MOV	MPA1,R2			;R2 -  адрес выделенной памяти
		ADD	R5,MPA1			;MPA1 = MPA1 + R5 (адрес PPU для копирования программы)
		MOV	R3,MPA2			;MPA2 - адрес программы
		MOV	R4,MPA3			;MPA3 - длина программы
		MOVB	#16,MPType		;Комана копирования из памяти CPU в память PPU
		CALL	PPUOut			;=> Передача параметров
		BNE	PPUErr			;Если ошибка, то --> PPUErr
	
		CLR	FlgEnd			;Очищаем флаг завершения программы PPU
		MOVB	#24,MPType		;Комана запуска программы PPU
		CALL	PPUOut			;=> Передача параметров
		BNE	PPUErr			;Если ошибка, то --> PPUErr

1$:		TST	FlgEnd			;Ожидаем окончания выполнения программы PPU
		BEQ	1$			;

		MOV	R2,MPA1			;Записать адрес выделенной памяти в аргумент 1
		ADD	R4,R5			;
		MOV	R5,MPA2			;Записать длину выделенной памяти в аргумент 2
		MOVB	#2,MPType		;Комана освобождения памяти PPU
		CALL	PPUOut			;=> Передача параметров
		BNE	PPUErr			;Если ошибка, то --> PPUErr
		
		RETURN				;Выход

;----------------------------------------------- Ошибка обмена с PPU
PPUErr:						
     		.PRINT     #tPPUErr		;Печатаем сообщение об ошибке
    		.EXIT				;Выход в систему
			
			
			
;===================================================================================
;
;	      Тестирование одной команды (группы команд) CPU
;
;	Входные данные:	R1 - указатель текущую запись в таблице тестов
;	Выходные данные: R1 - указатель на следующую запись в таблице тестов
;
;===================================================================================
CPUTCom:
		MOV	R1,-(SP)		;
		MOV	#NextL0,R1		;Переход на следующую строчку
		CALL	PrnStr			;
		MOV	(SP)+,R1		;

		.TTYOUT #9			;Печать символа <9> (Табуляция)

		CALL	PrnStr			;Печать мнемоники по адресу R1

		.TTYOUT #9			;Печать символа <9> (Табуляция)
		.TTYOUT #45			;Печать символа "-"
		.TTYOUT #32			;Печать пробела
		
		MOV	R1,R0			;R0 = R1
		INC	R0			;Even R0 (выравнивание на границу слова)
		BIC	#1,R0			;


1$:     	BIT     #64,@#^O177564		;Ожидаенм запрещения прерываний источника-0
        	BNE     1$			;(окончание системной печати TTYOUT)
        	
        	MOV	@#^O177560,-(SP)	;Сохранить регистр состояния приемника-0
        	CLR	@#^O177560		;Запретить прерывания от приемника-0
        	
		CALL	RTestFunc		;Инициализация и запуск тестирования
		
		MOV	(SP)+,@#^O177560	;Восстановить регистр состояния приемника-0
		

;-----------------------------------------------
TComCont:
		TST	R5			;Если не было ошибок шины, то
		BEQ	2$			;--> 2$
		
		.Print	#tBusError		;печать "Ошибка шины"

		MOV	(R1)+,R2		;R2 - требуемое количество тактов
					
		RETURN				;Выход

;----------------------------------------------- [T] Тест
2$:
		MOV	R0,-(SP)
		MOV	R4,-(SP)
		
		.TTYOUT #32			;Печать пробела
		
		MOV	R2,R3			;R3 - число
		CALL	PSBDec			;Печать целое число тактов

		.TTYOUT #32			;Печать пробела
		
		MOV	(SP)+,R4
		MOV	(SP)+,R0
	
;-----------------------------------------------


		MOV	(R1)+,R2		;R2 - требуемое количество тактов
						;R1 - указатель на следующий элемент таблицы
						;R4 - целая часть тактов
						;R0 - дробная часть тактов * 100
		
						;R4 - целая часть, R0 - дробная часть * 100
		CALL	PrFrac			;Печать число тактов в команде		
		
;		.TTYOUT #9			;Печать символа <9> (Табуляция)

		CMP	R4,R2			;Если R4 = R2,
		BNE	1$			;то
;		.Print	#TxtOK			;печать "ОК"
		
		RETURN				;Выход
	
;----------------------------------------------- R4 <> R2
1$:
;		.Print	#TxtER2			;Печать "Error, must be: "
		
		MOV	R2,R3			;R3 - число
;		CALL	PSBDec			;Печать целое число требуемых тактов
				
		RETURN				;Выход
		

;===================================================================================
;
;	      Тестирование одной команды (группы команд) PPU
;
;	Входные данные:	R1 - указатель текущую запись в таблице тестов
;	Выходные данные: R1 - указатель на следующую запись в таблице тестов
;
;===================================================================================
PPUTCom:
		MOV	R1,-(SP)		;
		MOV	#NextL0,R1		;Переход на следующую строчку
		CALL	PrnStr			;
		MOV	(SP)+,R1		;

		.TTYOUT #9			;Печать символа <9> (Табуляция)

		CALL	PrnStr			;Печать мнемоники по адресу R1

		.TTYOUT #9			;Печать символа <9> (Табуляция)
		.TTYOUT #45			;Печать символа "-"
		.TTYOUT #32			;Печать пробела
		
		MOV	R1,R0			;R0 = R1
		INC	R0			;Even R0 (выравнивание на границу слова)
		BIC	#1,R0			;

		ADD	PPUDisp,R0		;PNextEl = R0 + PPUDisp (коррекция для памяти PPU)
		MOV	R0,PNextEl		;

		MOV	#RTFPPU,R0		;Аргумент 1 - RTFPPU + PPUDisp (адрес запуска программы в PPU)
		ADD	PPUDisp,R0		;
		MOV	R0,MPA1			;
		CLR	FlgEnd			;Очищаем флаг завершения программы PPU
		MOVB	#24,MPType		;Команда запуска программы PPU
		CALL	PPUOut			;=> Передача параметров
		BNE	PPUErr			;Если ошибка, то --> PPUErr

1$:		TST	FlgEnd			;Ожидаем окончания выполнения программы PPU
		BEQ	1$			;
		
		MOV	PNextEl,R1		;R1 = PNextEl - PPUDisp
		SUB	PPUDisp,R1		;		

		MOV	PComCtr,R2		;R2 = PComCtr
		MOV	PInteger,R4		;R4 = PInteger
		MOV	PFraction,R0		;R0 = PFraction
		MOV	PBErrCtr,R5		;R5 = PBErrCtr

		BR	TComCont		;--> TComCont (продолжить, как и для CPU)
		
;-----------------------------------------------



		













;===================================================================================
;
;	Печать NULL-terminated строку с вопросом перехода на следующий экран
;
;	Входные данные:	R1 - указатель на строку
;
;===================================================================================
			
PrnStr:
		CMP	LineCtr,#23		;Если напечатали < 23 строки, то
		BCS	4$			;пропустить вопрос --> 4$
		
;----------------------------------------------- Next page?

		MOV	R1,-(SP)		;Сохранить на стеке R1
		
		;[T] Восстановить системные вектора TRAP 4,10

		.Print	#NextPage		;Печатаем сообщение "Next page?"

		.Print	#KeyON			;Включить клавиатуру

  		 BIS     #TTSPC$,@#$JSW		;Запрет отображения символов на экране
  		 .TTYIN				;Ожидание нажатия клавиши
  		 CMPB	R0,#13			;Если код = 13 (Возврат каретки),
  		 BNE	3$			;то ожидаем еще один код = 10 (перевод строки)
  		 .TTYIN				;	 
3$:			 
		.Print	#KeyOFF			;Отключить клавиатуру
		
		.Print	#NextLine		;Переходим на следующую строку
	
		CLR	LineCtr			;Сбросить счетчик строк

		;[T] Вернуть наши вектора TRAP 4,10
		
		MOV	(SP)+,R1		;Восстановить R1
4$:
;----------------------------------------------- Печать символа

		MOVB	(R1)+,R0		;(R1)+ -> R0
		BEQ	1$			;Если равен 0, то выход --> 1$
		CMP	#10,R0			;Если равен 10, то 
 		BNE	2$			;		
		INC	LineCtr			;Прирастить счетчик строк
2$:		

		.TTYOUT				;Печать символа в R0
		
;		EMT	^O341			;Печать символа в R0
		
		BR	PrnStr			;Цикл		
1$:		

		RETURN				;Выход




;===================================================================================
;
;		Печать в буфер шестнадцатиричного числа
;
;	Входные данные:	R0 - указатель на буфер
;			R1 - число
;	Выходные данные: R0 - указатель на буфер после числа
;
;===================================================================================
PrBHex:		
		MOV	#4,R3			;Счетчик на 4 цифры
1$:		
		ADD	R1,R1			;Циклический сдвиг R1 влево
		ADC	R1			;на 4 бита
		ADD	R1,R1			;
		ADC	R1			;
		ADD	R1,R1			;
		ADC	R1			;
		ADD	R1,R1			;
		ADC	R1			;
	
		MOV	R1,R2			;Преобразовать младший ниббл R1 в шестнадцатиричную ASCII-цифру 
		BIC	#65520,R2		;AND $000F,R2
		CMP	R2,#10			;
		BCS	2$			;
		ADD	#7,R2			;		
2$:		ADD	#48,R2			;

		MOVB	R2,(R0)+		;Занести цифру в буфер
		
		SOB	R3,1$			;Цикл на 4 цифры
		
		RETURN				;Выход


;===================================================================================
;
;		Печать в буфер десятичного числа
;
;	Входные данные:	R0 - указатель на буфер
;			R1 - 0 - не печатать ведущие нули, <0 - печатать
;			R3 - число
;			R5 - вес старшего разряда
;	Выходные данные: R0 - указатель на буфер после числа
;	Портит регистры: R0..R5
;
;===================================================================================
PrBDec:
		CLR	R2			;R2.R3 - число		
		SUB	R4,R4			;R4.R5 - вес разряда
		DIV	R5,R2			;R2 = R2.R3/R5, R3 - остаток
		CMP	R2,R1			;Если R2 = R1, 
		BEQ	1$			;то пропускаем цифру --> 1$
		DEC	R1			;Снимаем флаг, запрещающий печатать нули
		ADD	#48,R2			;R2 - ASCII-цифра
		MOVB	R2,(R0)+		;R2 -> (R0)+ (заносим цифру в буфер)
1$:		DIV	#10,R4			;R4 = R4.R5 / 10 (перейти к следущему разряду)	
		MOV	R4,R5			;R5 = R4
		BNE	PrBDec			;Если вес разряда <> 0, то цикл --> PrBDec
		
		RETURN				;Выход

;===================================================================================
;
;		Печать на экран десятичного числа без ведущих нулей
;
;	Входные данные:	R3 - число 0..65535
;	Портит регистры: R0, R2..R5
;
;===================================================================================
PSBDec:
		MOV	R1,-(SP)		;Сохранить R1 на стеке
					
		MOV	#TextBuf,R0		;R0 - буфер для печати
		CLR	R1			;R1 = 0 (не печатать ведущие нули)
		MOV	#10000,R5		;Число до 5 знаков
		CALL	PrBDec			;Печатать в буфер R1
		CLRB	(R0)			;Закрыть стринг
		
		MOV	#TextBuf,R1		;
		CALL	PrnStr			;Печатать число из буфера на экране
	
		MOV	(SP)+,R1		;Восстановить R1
	
		RETURN				;Выход
		
		
;=============================================== Печать в буфер десятичного числа с плавающей точкой [T]

						;R4.R5/R2 - число в формате дроби
;;;PrFrac:
		MOV	#TextBuf,R0		;R0 - буфер для печати

		DIV	R2,R4			;R4 = R4.R5 / R2, R5 - остаток
		
		MOV	R2,-(SP)		;Сохранить R2
		MOV	R5,-(SP)		;Сохранить R5
		MOV	R4,R3			;
		SUB	R1,R1			; 
		MOV	#100,R5			;
		CALL	PrBDec			;Печатать 3-х значное десятичное число в R3 без ведущих нулей
		MOV	(SP)+,R5		;Восстановить R5
		MOV	(SP)+,R3		;Восстановить R3 (делитель)
		
		MOVB	#46,(R0)+		;'.'
		
		SUB	R4,R4			;
		TST	R5			;Если остаток равен 0, то R4 = 0,
		BEQ	1$			;--> 1$
		
		SUB	R2,R2			;
		DIV	R5,R2			;R2 = R3 / R5 (дробная часть в формате 1/R2)
		
		MOV	#10000,R5		;
		DIV	R2,R4			;R4 = 10000 / R2 (дробная часть * 10000)
	
		CMP	R4,#10000		;Если дробная часть равна 10000,
		BNE	1$			;то округлить ее до 9999
		DEC	R4			;
	
1$:			
		MOV	R4,R3			;
		MOV	#1000,R5		;
		CALL	PrBDec			;Печатать 4-х значное десятичное число в R3 с ведущими нулями
	
		CLRB	(R0)+			;Закрыть стринг
	
		MOV	#TextBuf,R1		;
		CALL	PrnStr			;Печатать число из буфера на экране
	
		RETURN				;Выход

;===================================================================================
;
;		Печатать на экране дробное число в формате 3.2
;
;	Входные данные:  R4 - целая часть числа
;			 R0 - дробная часть числа * 100
;	Портит регистры: R0, R3, R5
;
;===================================================================================
PrFrac:
		MOV	R1,-(SP)		;Сохранить R1 на стеке
		MOV	R2,-(SP)		;Сохранить R2 на стеке
		MOV	R4,-(SP)		;Сохранить R4 на стеке
		
		MOV	R0,-(SP)		;Сохранить на стеке R0
		
		MOV	#TextBuf,R0		;R0 - буфер для печати
		MOV	R4,R3			;R3 - целая часть числа
		CLR	R1			;Не печатать ведущие нули
		MOV	#100,R5			;Трехзначное число
		CALL	PrBDec			;Печатать 3-х значное десятичное число в R3 без ведущих нулей

		MOVB	#46,(R0)+		;'.'
		
		MOV	(SP)+,R3		;R3 - дробная часть числа
						;R1 < 0 (печатать ведущие нули)
		MOV	#10,R5			;Двузначное число
		CALL	PrBDec			;Печатать 2-х значное десятичное число в R3 с ведущими нулями
	
		CLRB	(R0)+			;Закрыть стринг
	
		MOV	#TextBuf,R1		;
		CALL	PrnStr			;Печатать число из буфера на экране
	
		MOV	(SP)+,R4		;Восстановить R4
		MOV	(SP)+,R2		;Восстановить R2
		MOV	(SP)+,R1		;Восстановить R1
		
		RETURN				;Выход


;=============================================== Печать результата теста правильности команды CPU

						;R0 - результат теста (0xA5A1, 0xA5A2 - TRAP 4 и TRAP 10)
PrTstRes:
		MOV	R1,-(SP)		;Сохранить R1 на стеке
					
		MOV	#TTrap4,R1		;Если R0 = 0xA5A1,
		CMP	#42401,R0		;то печатать "Trap 4"
		BEQ	1$			;--> PrnStr
		
		MOV	#TTrap10,R1		;Если R0 = 0xA5A2,
		CMP	#42402,R0		;то печатать "Trap 10"
		BEQ	1$			;--> PrnStr
	
		MOV	R0,R1			;R1 - число
		MOV	#TextBuf,R0		;R0 - буфер для печати
		MOVB	#48,(R0)+		;Занести в буфер "0x"
		MOVB	#120,(R0)+		;
		CALL	PrBHex			;Печатать в буфер R1
		CLRB	(R0)			;Закрыть стринг
		
		MOV	#TextBuf,R1		;
1$:		CALL	PrnStr			;Печатать число из буфера на экране
	
		MOV	(SP)+,R1		;Восстановить R1
	
		RETURN				;Выход


;===================================================================================
;
;			Функция обмена информацией с PPU
;
;===================================================================================
PPUOut:
		MOV	#AMP,R0			;R0 - Указатель на массив инициализации
		MOV	#8,R1			;R1 - счетчик на 9 байт
1$:		
		MOVB	(R0)+,@#CSR2DATA	;(R0) -> Канал-2
2$:		TSTB	@#CSR2STATE		;Ждать готовности
		BPL	2$			;
		
		SOB	R1,1$			;Цикл на R1 байт

		TSTB	MP			;Тестировать байт ответа PPU
		RETURN				;Выход

AMP:		.BYTE	0, 0, 0, 255		;Массив инициализации из неопределенного состояния
		.WORD	MP, 65535		;Адрес массива параметров, и два терминатора 255, 255

MP:		.BYTE	0			;Байт ответа
MPType:		.BYTE	1, 26, 0		;Команда, тип устройства (ОЗУ ПП), номер устройства
MPA1:		.WORD	0			;Аргумент 1
MPA2:		.WORD	0			;Аргумент 2
MPA3:		.WORD	0			;Аргумент 3

FlgEnd:		.WORD	0			;Флаг завершения работы программы 
	
	

;===================================================================================
		
		




;===================================================================================
;
;			  Начало перемещаемой области
;
;===================================================================================
PPUTBeg:

;===================================================================================
;
;		Главная функция тестирования быстродействия PPU, CPU, Hardware
;				(полностью перемещаемая)
;
;	Входные данные:  R0 - указатель на текущий параметр в таблице инициализации
;	Выходные данные: R2 - число выполненных команд (групп команд)
;			 R4 - число выполненных циклов
;
;=================================================================================== 
RTFPPU:						;Точка входа для PPU
		MOV	#PNextEl/2,@#PPLADR	;(PNextEl) -> R0 
		MOV	@#PPL12DATA,R0		;
		
;----------------------------------------------- Точка входа для CPU
RTestFunc:

		MOV	PC,R1			;Записать абсолютный адрес TMExit
		ADD	#TMExit-.,R1		;в TMHandler+2
		MOV	PC,R2			;
		ADD	#TMHandler+2-.,R2	;
		MOV	R1,(R2)			;

		MOV	PC,R1			;
		ADD	#OpBufLoop-.,R1		;R1 - адрес начала буфера команд

		MOV	(R0)+,(R1)+		;Заносим в буфер слово команды инициализации каждого цикла

		MOV	(R0)+,R4		;R4 - число слов в тестируемой последовательности команд
		
		MOV	PC,R2			;
		ADD	#OpBufEnd-.,R2		;R2 - адрес конца буфера команд
2$:		MOV	R4,R5			;R5 = R4 - счетчик слов для команды (группы команд)
		MOV	R0,R3			;R3 = R0 - адрес последовательности
1$:		MOV	(R3)+,(R1)+		;Копировать одну последовательность
		DEC	R5			;
		BNE	1$			;
		CMP	R1,R2			;
		BNE	2$			;
						
;----------------------------------------------- Инициализация блока данных

		MOV	(R3)+,R0		;R0 - адрес функции инициализации
		BEQ	SkipInitFunc		;Если = 0, то идем далее -->
		
		MOV	PC,R1			;
		ADD	#DBuf-.,R1		;R1 = DBuf - адрес начала буфера данных
		MOV	#2048,R2		;R2 = 2048 - длина буфера данных в словах
		
		SUB	#2,R0			;
DFBase:		ADD	PC,R0			;R0 = R0 + DFBase - 2
		JSR	PC,(R0)			;Вызвать функцию инициализации ==>	
SkipInitFunc:

		MOV	R3,-(SP)		;Сохранить указатель на следующий элемент таблицы
		MOV	R4,-(SP)		;Сохранить счетчик слов в команде

;-----------------------------------------------

		MOV	PC,R5			;
		ADD	#OpBufLoop-.,R5		;R5 = OpBufLoop (адрес для зацикливания)
		MOV	#0,R4			;R4 = 0 (инициализация счетчика циклов)
	
		MTPS	#^O340			;Запретить прерывания
	
		MOV	@#^O100,CPC100		;Сохранить вектор текущего прерывания от сетевого таймера
		MOV	@#^O102,CSW100		;в CPC100/CSW100

		MOV	@#^O004,CPC004		;Сохранить вектор текущего прерывания по ошибке шины
		MOV	@#^O006,CSW004		;в CPC004/CSW004
	
		MOV	#^O340,@#^O006		;$00 -> PSW вектора прерывания по ошибке шины (прерывания запрещены)
		MOV	PC,R2			;	
		ADD	#BEHandler-.,R2		;
		MOV	R2,@#^O004		;BEHandler -> адрес вектора прерывания по ошибке шины
	
		MOV	#0,@#^O102		;$00 -> PSW вектора прерывания от сетевого таймера (прерывания разрешены)
		MOV	PC,R2			;	
		ADD	#TMInit-.,R2		;
		MOV	R2,@#^O100		;TMInit -> адрес вектора прерываний от сетевого таймера
	
		CLR	BusErrCtr		;Сбросить счетчик ошибок шины
	
						;Подготавливаем констанды для использования в цикле
						;R0, R1 - константы наследуемые из функции инициализации блока данных
		MOV	PC,R2			;
		ADD	#DBuf-.,R2		;R2 - адрес начала буфера данных
		MOV	PC,R3			;
		ADD	#DBufEnd-.,R3		;R3 - адрес конца буфера данных
						;R4 - зарезервирован под счетчик циклов
						;R5 - адрес зацикливания
		
		MTPS	#0			;Разрешить прерывания
	
;	MOV	SP,SP				;[T] Точка останова
	
3$:		BR	3$			;Остановка программы и ожидание прерываний	
	
;=============================================== Первая итерация прерывания от сетевого таймера
						;Необходима для избежания случая, когда запрос на прерывания 
						;от таймера уже установлен, а прерывания запрещены, в связи с чем
						;прерывание наступает с запозданием.
TMInit:	
		MOV	R0,-(SP)		;
		MOV	PC,R0			;
		ADD	#TMHandler-.,R0		;
		MOV	R0,@#^O100		;Адрес вектора = TMHandler
		MOV	(SP)+,R0		;
		RTI				;

;=============================================== Главный цикл тестирования команд
TMHandler:
		MOV	#TMExit,@#^O100		;Адрес вектора = TMHandler

OpBufLoop:
		.WORD	0			;Комада подготовки данных для каждого цикла		
OpBuf:
		.BLKW	2048			;Буфер для тестируемых команд
OpBufEnd:
		INC	R4			;Увеличиваем счетчик циклов
		JMP	(R5)			;Бесконечный цикл --> OpBufLoop


;=============================================== Буфер данных

DBuf:
		.BLKW	2048			;Буфер для данных и стека тестируемых команд
DBufEnd:
	
;===============================================
TMExit:						;Обработчик прерывания для выхода из цикла измерений
		MOV	(SP)+,R5		;R5 - адрес прерывания цикла
		MOV	PC,R2			;
		ADD	#CPUTCnt-.,R2		;
		MOV	R2,-(SP)		;Взамен на стек положить адрес продолжения программы CPUTCnt

		MOV	CSW004,@#^O006		;Восстановить PSW вектора 004
		MOV	CPC004,@#^O004		;Восстановить адрес обработки прерывания

		MOV	CSW100,@#^O102		;Восстановить PSW вектора 100
		MOV	CPC100,@#^O100		;Восстановить адрес обработки прерывания

		RTI				;Выход из прерывания 
		
;-----------------------------------------------
CPUTCnt:	
		ADD	#4,SP			;Восстановить стек после одного вложенного прерывания

		MOV	PC,R2			;
		ADD	#OpBuf-.,R2		;
		SUB	R2,R5			;R5 = R5 - OpBuf (число слов команд, выполненное в последнем цикле)
		ASR	R5			;

		CMP	R5,#2049		;Если число слов >= 2049,
		BCS	1$			;значит не успели перейти на следующий цикл,
		SUB	R5,R5			;сбросить число слов в 0
1$:
		
		MOV	R4,R2			;R2.R3 = R4 * 2048 + R5 
		MUL	#2048,R2		;(число выполненных слов команд за все циклы)
		ADD	R5,R3			;

		MOV	(SP)+,R0		;R0 - число слов в команде
		DIV	R0,R2			;R2 = R2.R3 / R0 (делим общее число слов на число слов в команде)

 						;R2 - число команд, R4 - число циклов
	
		TST	PPUFlg			;Если выполняет CPU, 
		BEQ	2$			;то --> 2$

;----------------------------------------------- PPU Presets

		MOV	#TPLPPU,R5		;R5 = R4 * TPLPPU
		MUL	R4,R5			;(число лишних тактов на цикл умноженное на количество циклов)
		
		NEG	R5			;R4.R5 = 124800 - TPSPPU - (TPLPPU * R4)
		ADD	#59264,R5		;(перенос в старшее слово не учитывается, т.к.
		SUB	#TPSPPU,R5		;59264 намного больше вычитаемого числа)
		MOV	#1,R4			;
		
		BR	3$			;--> 3$
		
;----------------------------------------------- CPU Presets
2$:
		MOV	#TPLCPU,R5		;R5 = R4 * TPLCPU
		MUL	R4,R5			;(число лишних тактов на цикл умноженное на количество циклов)
		
		NEG	R5			;R4.R5 = 159744 - TPSCPU - (TPLCPU * R4)
		ADD	#28672,R5		;(перенос в старшее слово не учитывается, т.к.
		SUB	#TPSCPU,R5		;28672 намного больше вычитаемого числа)
		MOV	#2,R4			;
3$:	
;----------------------------------------------- R4.R5 - число тактов, R2 - число команд
											
		DIV	R2,R4			;R4 = R4.R5 / R2, R5 - остаток
		
		MOV	R5,R0			;R0.R1 = R5 * 1000 (остаток * 1000)
		MUL	#1000,R0		;
			
		DIV	R2,R0			;R0 = R0.R1 / R2 (дробная часть * 1000)

		MOV	R0,R1			;R0 = (R0 + 5) / 10 (округление на один разряд)
		CLR	R0			;
		ADD	#5,R1			;
		DIV	#10,R0			;
		
		CMP	#100,R0			;Если после округления произошел перенос в целую 
		BNE	5$			;часть числа, то обнулить дробную часть, 
		CLR	R0			;и инкрементировать целую часть числа
		INC	R4			;
5$:
						;R4 - целая часть, R0 - дробная часть
	
 		MOV	(SP)+,R1		;R1 - указатель на следующий элемент таблицы
 						
 		TST	(R1)			;Проверяем следующий элемент из таблицы
 		BPL	6$			;Если >= 0, то далее -->
 		ADD	(R1)+,R4		;Иначе использовать элемент для коррекции целого числа тактов
6$:		

		MOV	BusErrCtr,R5		;R5 - число ошибок шины

		TST	PPUFlg			;Если выполняет CPU, 
		BEQ	7$			;то --> 7$
		
;----------------------------------------------- Точка выхода для PPU

		MOV	#PBErrCtr/2,@#PPLADR	;R5 -> (PBErrCtr)
		MOV	R5,@#PPL12DATA		;
		MOV	#PNextEl/2,@#PPLADR	;R1 -> (PNextEl)
		MOV	R1,@#PPL12DATA		;
		MOV	#PComCtr/2,@#PPLADR	;R2 -> (PComCtr)
		MOV	R2,@#PPL12DATA		;
		MOV	#PInteger/2,@#PPLADR	;R4 -> (PInteger)
		MOV	R4,@#PPL12DATA		;
		MOV	#PFraction/2,@#PPLADR	;R0 -> (PFraction)
		MOV	R0,@#PPL12DATA		;
						
		MOV	#FlgEnd/2,@#PPLADR	;-1 -> (FlgEnd)
		MOV	#-1,@#PPL12DATA		;(конец работы подпрограммы PPU)

;-----------------------------------------------
7$:				
		RETURN				;Выход
		
		
;===================================================================================
;
;			Обработчик прерывания по ошибке шины
;
;=================================================================================== 
BEHandler:	
		INC	BusErrCtr		;Прирастить число ошибок шины

		RTI				;Выход из прерывания


;===================================================================================
;
;		Функции инициализации блоков данных для тестов быстродействия
;				(полностью перемещаемые)
;
;	Входные данные:  R1 - адрес начала буфера данных
;			 R2 - длина буфера данных в словах
;			 R3 - указатель на следующий элемент таблицы
;	Можно использовать регистры: R0, R1, R2, R5
;
;=================================================================================== 

;----------------------------------------------- Функция для команд с адресацией типа @-(Rx)+
DFillTEMP:			
		MOV	PC,R0			;
		ADD	#TEMP-.,R0		;R0 = TEMP	
1$:		MOV	R0,(R1)+		;Заполнить буфер DBuf
		DEC	R2			;адресом переменной TEMP
		BNE	1$			;	
	
		RETURN				;Выход
		
;----------------------------------------------- Функция для команды JMP (R2); ADD R1,R2
DJump1:
		MOV	PC,R0			;
		ADD	#OpBuf+2-.,R0		;R0 = OpBuf + 2
		MOV	#4,R1			;R1 = 4
		
		RETURN				;Выход
		
;----------------------------------------------- Функция для команды JMP (R2); NOP; NOP; ADD R1,R2
DJump2:
		MOV	PC,R0			;
		ADD	#OpBuf+6-.,R0		;R0 = OpBuf + 6
		MOV	#8,R1			;R1 = 8
		
		RETURN				;Выход		

;----------------------------------------------- Функция для команд с O^010000 (MOV R0,R0) в регистре R0
DR0NOP:
		MOV	#^O010000,R0		;R0 = O^010000 (MOV R0,R0)

		RETURN				;Выход

;----------------------------------------------- Функция для команды тестирования кэша
DCach1:
		MOV	PC,R0			;
		ADD	#OpBuf+2-.,R0		;R0 = OpBuf + 2
		MOV	#^O062702,R1		;R1 = 'ADD #nnnn,R2'
		
		RETURN				;Выход

DCach2:
		MOV	PC,R0			;
		ADD	#OpBuf+2-.,R0		;R0 = OpBuf + 2
		
		RETURN				;Выход

DCach3:
		MOV	PC,R0			;
		ADD	#OpBuf+4-.,R0		;R0 = OpBuf + 4
		
		RETURN				;Выход


;===============================================

CPC004:		.WORD	0			;Вектор 004
CSW004:		.WORD	0			;
CPC100:		.WORD	0			;Вектор 100
CSW100:		.WORD	0			;

BusErrCtr:	.WORD	0			;Число ошибок шины (>0 - ошибки шины)

TEMP:		.WORD	0			;Слово для временного использования

PPUFlg:		.WORD	1			;Флаг того, что программа выполняется PPU
PPUDisp:	.WORD	0			;Смещение программы в PPU относительно той же программы в CPU

;===================================================================================
;	
;		Таблица шаблонов для замера скорости CPU/PPU/Hardware
;
;	Входные данные для тестов: R0, R1 - константы, наследуемые из функции инициализации блока данных
;				   R2 - адрес начала буфера данных (DBuf)
;				   R3 - адрес конца буфера данных (DBufEnd)
;				   R4 - счетчик циклов
;				   R5 - адрес зацикливания
;
;===================================================================================
CPUTTAB:

		.ASCIZ	"NOP"<9><9>		;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	1			;Число слов в команде (должно быть кратно степени 2)
		NOP				;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	8			;Правильное число тактов
		
		.ASCIZ	"MOV"<9>"R0,R0"<9>	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		MOV	R0,R0			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"MOV"<9>"#nnnn,R0"	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	2			;Число слов в команде
		MOV	#1234,R0		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"MOV"<9>"(R0),R1"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		MOV	(R0),R1			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"MOV"<9>"(R0)+,R1"	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		MOV	(R0)+,R1		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"MOV"<9>"-(R0),R1"	;Мнемоника команды
		.Even				;
		MOV	R3,R0			;Команда инициализации цикла (R0 = DBufEnd)
		.WORD	1			;Число слов в команде
		MOV	-(R0),R1		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"MOV"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		MOV	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"MOV"<9>"R1,(R0)+"	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		MOV	R1,(R0)+		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"MOV"<9>"R1,-(R0)"	;Мнемоника команды
		.Even				;
		MOV	R3,R0			;Команда инициализации цикла (R0 = DBufEnd)
		.WORD	1			;Число слов в команде
		MOV	R1,-(R0)		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"MOV"<9>"(R0),(R0)"	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		MOV	(R0),(R0)		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"MOV"<9>"nnnn(R0),R1"	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	2			;Число слов в команде
		MOV	10(R0),R1		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"MOV"<9>"R1,nnnn(R0)"	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	2			;Число слов в команде
		MOV	R1,10(R0)		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"MOV"<9>"@(R0)+,R1"	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		MOV	@(R0)+,R1		;Код команды
		.WORD	DFillTEMP-DFBase	;Функция инициализации данных DFillTEMP
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"MOV"<9>"R1,@(R0)+"	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		MOV	R1,@(R0)+		;Код команды
		.WORD	DFillTEMP-DFBase	;Функция инициализации данных DFillTEMP
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"MOV"<9>"@nnnn(R0),R1"	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	2			;Число слов в команде
		MOV	@0(R0),R1		;Код команды
		.WORD	DFillTEMP-DFBase	;Функция инициализации данных DFillTEMP
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"CLR"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		CLR	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"INC"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		INC	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"TST"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		TST	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
				

;----------------------------------------------- Байтовые команды

		.ASCIZ	"MOVB"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		MOVB	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"CMPB"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		CMPB	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"BITB"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		BITB	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"BICB"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		BICB	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"BISB"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		BISB	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"MFPS"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		MFPS	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"CLRB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		CLRB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"COMB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		COMB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"INCB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		INCB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"DECB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		DECB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"NEGB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		NEGB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"TSTB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		TSTB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"ROLB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		ROLB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"RORB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		RORB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"ASRB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		ASRB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"ASLB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		ASLB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"ADCB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		ADCB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов


;----------------------------------------------- Словные команды

		.ASCIZ	"CMP"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		CMP	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"BIT"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		BIT	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"BIC"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		BIC	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"BIS"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		BIS	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"COM"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		COM	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
				
		.ASCIZ	"DEC"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		DEC	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"NEG"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		NEG	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"TST"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		TST	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"ROL"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		ROL	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"ROR"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		ROR	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"ASR"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		ASR	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"ASL"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		ASL	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"ADC"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		ADC	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"SWAB"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		SWAB	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"XOR"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		XOR	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"ADD"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		ADD	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"SUB"<9>"R1,(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		SUB	R1,(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
	
		.ASCIZ	"SXT"<9>"(R0)"<9>	;Мнемоника команды
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R0 = DBuf)
		.WORD	1			;Число слов в команде
		SXT	(R0)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
;----------------------------------------------- Команды переходов	
		
		.ASCIZ	"JMP"<9>"(PC)"<9>	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		JMP	(PC)			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"JMP"<9>"#nnnn(PC)"	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	2			;Число слов в команде
		.WORD	^O000167,0		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		

		




;----------------------------------------------- Команды расширеной арифметики

		.ASCIZ	"MUL"<9>"R2,R3"<9>	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		MUL	R2,R3			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"ASH"<9>"R2,R2"<9>	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		ASH	R2,R2			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		
		.ASCIZ	"ASH"<9>"R3,R2"<9>	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		ASH	R3,R2			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"ASHC"<9>"R2,R2"<9>	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		ASHC	R2,R2			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"ASHC"<9>"R2,R3"<9>	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		ASHC	R2,R3			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"DIV"<9>"Rn,Rn"<9>	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		DIV	R2,R2			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов


		.ASCIZ	"DIV"<9>"#nnnn,R3"	;Мнемоника команды
		.Even				;
		NOP				;Команда инициализации цикла
		.WORD	2			;Число слов в команде
		DIV	#1,R3			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов
		

;----------------------------------------------- Специфические адресации
BLABLA:
		.ASCII	<13><10><9>
		
		.ASCIZ	"MOV"<9>"(PC),R0"<9>	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		MOV	(PC),R0			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"MOVB"<9>"(PC),R0"<9>	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		MOVB	(PC),R0			;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"MOV"<9>"(PC)+,R0"	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	2			;Число слов в команде
		MOV	(PC)+,R0		;Код команды
		NOP				;
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"MOVB"<9>"(PC)+,R0"	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	2			;Число слов в команде
		MOVB	(PC)+,R0		;Код команды
		NOP				;
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"MOV"<9>"(PC),(PC)"	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		MOV	(PC),(PC)		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"MOVB"<9>"(PC),(PC)"	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		MOVB	(PC),(PC)		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"MOV"<9>"(PC),(PC)+"	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		MOV	(PC),(PC)+		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"MOVB"<9>"(PC),(PC)+"	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	1			;Число слов в команде
		MOVB	(PC),(PC)+		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCII	<13><10><9>
		.ASCII	"MOV"<9>"(PC)+,(PC)"<13><10><9>	;Мнемоника команды
		.ASCIZ	"MOV"<9>"R0,R0 (2)"	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	4			;Число слов в команде
		MOV	(PC)+,(PC)		;Код команды
		MOV	R0,R0			;
		MOV	R0,R0			;		
		MOV	R0,R0			;		
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов


		.ASCII	<13><10><9>
		.ASCII	"MOVB"<9>"(PC)+,(PC)"<13><10><9>;Мнемоника команды
		.ASCIZ	"MOV"<9>"R0,R0 (2)"	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	4			;Число слов в команде
		MOVB	(PC)+,(PC)		;Код команды
		MOV	R0,R0			;
		MOV	R0,R0			;		
		MOV	R0,R0			;		
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCII	<13><10><9>
		.ASCII	"MOV"<9>"(PC)+,(PC)+"<13><10><9>;Мнемоника команды
		.ASCIZ	"MOV"<9>"R0,R0"<9>	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	4			;Число слов в команде
		MOV	(PC)+,(PC)+		;Код команды
		MOV	R0,R0			;
		MOV	R0,R0			;		
		MOV	R0,R0			;		
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCII	<13><10><9>
		.ASCII	"MOVB"<9>"(PC)+,(PC)+"<13><10><9>;Мнемоника команды
		.ASCIZ	"MOV"<9>"R0,R0"<9>	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	4			;Число слов в команде
		MOVB	(PC)+,(PC)+		;Код команды
		MOV	R0,R0			;
		MOV	R0,R0			;		
		MOV	R0,R0			;		
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCII	<13><10><9>
		.ASCII	"MOV"<9>"R0,(PC)"<13><10><9>;Мнемоника команды
		.ASCIZ	"MOV"<9>"R0,R0"<9>	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	2			;Число слов в команде
		MOV	R0,(PC)			;Код команды
		MOV	R0,R0			;
		.WORD	DR0NOP-DFBase		;Функция инициализации данных DR0NOP
		.WORD	1			;Правильное число тактов

		.ASCII	<13><10><9>
		.ASCII	"MOVB"<9>"R0,(PC)"<13><10><9>;Мнемоника команды
		.ASCIZ	"MOV"<9>"R0,R0"<9>	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	2			;Число слов в команде
		MOVB	R0,(PC)			;Код команды
		MOV	R0,R0			;
		.WORD	DR0NOP-DFBase		;Функция инициализации данных DR0NOP
		.WORD	1			;Правильное число тактов

		.ASCII	<13><10><9>
		.ASCIZ	"MOV"<9>"R0,(PC)+"	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	2			;Число слов в команде
		MOV	R0,(PC)+		;Код команды
		MOV	R0,R0			;
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов

		.ASCIZ	"MOVB"<9>"R0,(PC)+"	;Мнемоника команды
		.Even				;
		MOV	R0,R0			;Команда инициализации цикла
		.WORD	2			;Число слов в команде
		MOVB	R0,(PC)+		;Код команды
		MOV	R0,R0			;
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов


;----------------------------------------------- Тест кэша

		.ASCII	<13><10><14>"tEST K\[A:"<15><13><10><9>

		.ASCII	"MOV"<9>"R1,(R2)"<13><10><9>;Мнемоника команды
		.ASCII	"ADD"<9>"#8,R2"<14>" (PROPUSK)"<15><13><10><9>;
		.ASCIZ	"MOV"<9>"R2,R2"<9>	;
		.Even				;
		MOV	R0,R2			;Команда инициализации цикла (R0 = OpBuf+2)
		.WORD	4			;Число слов в команде
		MOV	R1,(R2)			;Код команды
		ADD	#8,R2			;
		MOV	R2,R2			;
		.WORD	DCach1-DFBase		;Функция инициализации данных DFillTEMP
		.WORD	1			;Правильное число тактов


		.ASCII	<13><10><9>
		.ASCII	"MOV"<9>"R1,(R0)"<13><10><9>;Мнемоника команды
		.ASCII	"ADD"<9>"#8,R0"<14>" (K\[)"<15><13><10><9>;
		.ASCIZ	"MOV"<9>"R0,R0"<9>	;
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R2 = DBuf)
		.WORD	4			;Число слов в команде
		MOV	R1,(R0)			;Код команды
		ADD	#8,R0			;
		MOV	R0,R0			;
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов


		.ASCII	<13><10><9>
		.ASCIZ	"MOV"<9>"(R2),(R2)+"<14>" (PROPUSK)"<15><13><10><9><9><9>;
		.Even				;
		MOV	R0,R2			;Команда инициализации цикла (R0 = OpBuf+2)
		.WORD	1			;Число слов в команде
		MOV	(R2),(R2)+		;Код команды
		.WORD	DCach2-DFBase		;Функция инициализации данных DFillTEMP
		.WORD	1			;Правильное число тактов

		.ASCII	<13><10><9>
		.ASCIZ	"MOV"<9>"(R2),(R2)+"<14>" (PROPUSK+)"<15><13><10><9><9><9>;
		.Even				;
		MOV	R0,R2			;Команда инициализации цикла (R0 = OpBuf+2)
		.WORD	1			;Число слов в команде
		MOV	(R2),(R2)+		;Код команды
		.WORD	DCach3-DFBase		;Функция инициализации данных DFillTEMP
		.WORD	1			;Правильное число тактов

		.ASCII	<13><10><9>
		.ASCIZ	"MOV"<9>"(R0),(R0)+"<14>" (K\[)"<15><13><10><9><9><9>;
		.Even				;
		MOV	R2,R0			;Команда инициализации цикла (R2 = DBuf)
		.WORD	1			;Число слов в команде
		MOV	(R0),(R0)+		;Код команды
		.WORD	0			;Нет функции инициализации данных
		.WORD	1			;Правильное число тактов


		.ASCII	<13><10><9>
		.ASCII	"JMP"<9>"(R2)"<13><10>;Мнемоника команды
		.ASCIZ	<9>"ADD"<9>"R1,R2 ("<14>"PROPUSK"<15>")";
		.Even				;
		MOV	R0,R2			;Команда инициализации цикла
		.WORD	4			;Число слов в команде
		JMP	(R2)			;Код команды
		NOP				;
		NOP				;
		ADD	R1,R2			;
		.WORD	DJump2-DFBase		;Функция инициализации данных DJump2
		.WORD	1			;Правильное число тактов

		.ASCII	<13><10><9>
		.ASCII	"JMP"<9>"(R2)"<13><10>	;Мнемоника команды
		.ASCIZ	<9>"ADD"<9>"R1,R2 ("<14>"K\["<15>")";
		.Even				;
		MOV	R0,R2			;Команда инициализации цикла
		.WORD	2			;Число слов в команде
		JMP	(R2)			;Код команды
		ADD	R1,R2			;
		.WORD	DJump1-DFBase		;Функция инициализации данных DJump1
		.WORD	1			;Правильное число тактов













		
		.WORD	0			;0 - конец таблицы

PPUTEnd:
;===================================================================================
;
;			  Конец перемещаемой области
;
;===================================================================================








;===================================================================================

Text0:		.ASCIZ	<14>"tEST SKOROSTI RABOTY uknc"<15>" v0.1i (c) by dr.Titus"
Text1:		.ASCIZ	<13><10><13><10><14>"tEST WREMENI WYPOLNENIQ KOMAND cp:"<15>
Text3:		.ASCIZ	<13><10><13><10><14>"tEST WREMENI WYPOLNENIQ KOMAND pp:"<15>
tPPUErr:	.ASCIZ	<13><10><14>"o[IBKA INICIALIZACII "<15>"PPU!"

NextPage:	.ASCII	"Next page?"<128>

NextLine:	.ASCII	<13><10><128>
NextL0:		.ASCIZ	<13><10>

KeyOFF:		.ASCII	<27><91><50><104><128>
KeyON:		.ASCII	<27><91><50><108><128>

tBusError:	.ASCII	<14>"o[IBKA [INY"<15><128>

TTrap4:		.ASCIZ	"TRAP 4"
TTrap10:	.ASCIZ	"TRAP 10"

TxtOK:		.ASCII	"OK"<128>
TxtERROR:	.ASCII	"ERROR: "<128>
TxtSlash:	.ASCII	" / "<128>
TxtER2:		.ASCII	"Error, must be: "<128>


TextBuf:	.BLKB	64			;Текстовый буфер на 64 буквы

		.Even

;===============================================

LineCtr:	.WORD	0			;Счетчик строк

PPUMBeg:	.WORD	0			;Адрес начала выделенной памяти в PPU

PNextEl:	.WORD	0			;Адрес следующего элемента в таблице
PComCtr:	.WORD	0			;Число выполненных команд за один кадр
PInteger:	.WORD	0			;Целая часть числа
PFraction:	.WORD	0			;Дробная часть числа
PBErrCtr:	.WORD	0			;Число ошибок шины

























;===================================================================================

		.End	Start
;